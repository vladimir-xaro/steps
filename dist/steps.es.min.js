class t{constructor(t={}){this.events={};for(let s in t)t[s]&&this.subscribe(s,t[s])}subscribe(t,s){this.has(t)||(this.events[t]=[]);let i=[];if(Array.isArray(s))for(const e of s)i.push(...this.subscribe(t,e));else this.events[t].push(s),i.push((()=>this.removeListener(t,s)));return i}unsubscribe(...t){for(const s of t)this.events[s]&&delete this.events[s]}removeListener(t,s){if(Array.isArray(this.events[t])){const i=this.events[t].indexOf(s);i>-1&&this.events[t].splice(i,1)}}once(t,s){const i=this.subscribe(t,(()=>{i[0](),Array.isArray(s)?s.forEach((t=>t())):s()}))}has(t){return!!this.events[t]}listenerCount(t){return!!this.events.hasOwnProperty(t)&&this.events[t].length}emit(t,...s){const i=this.events[t];if(i)for(let t of i)t(...s)}validateEmit(t,...s){const i=this.events[t];if(!i)return!1;for(const t of i)if(!t(...s))return!1;return!0}seriesEmit(t,...s){const i=this.events[t];if(!i)return;let e;for(let t=0;t<i.length;t++)e=0===t?i[t](...s):i[t](e);return e}}const s={prev:{visibleIf:t=>t.current>0,on:{click:t=>{},lock:t=>{},unlock:t=>{}}},next:{visibleIf:t=>t.current<t.last-1,on:{click:t=>{},lock:t=>{},unlock:t=>{}}}};class i{constructor(i){this.steps=i.steps,this.emitter=new t(i.on),this.key=i.key,this.isLock=!!i.hasOwnProperty("isLock")&&i.isLock,this.isVisible=!i.hasOwnProperty("isVisible")||i.isVisible,this.validators={visibleIf:i.visibleIf||s[this.key].visibleIf},i.el&&(this.el=i.el,this.el.addEventListener("click",this.click.bind(this))),this.emitter.emit("init",this)}click(){this.isLock||this.emitter.emit("click",this)}hide(){this.isVisible&&this.el instanceof HTMLElement&&(this.emitter.emit("beforeHide",this),this.isVisible=!1,this.el.classList.add("hidden"),this.emitter.emit("afterHide",this))}show(){!this.isVisible&&this.el instanceof HTMLElement&&(this.emitter.emit("beforeShow",this),this.isVisible=!0,this.el.classList.remove("hidden"),this.emitter.emit("afterShow",this))}lock(){this.isLock||(this.emitter.emit("beforeLock",this),this.isLock=!0,this.emitter.emit("afterLock",this))}unlock(){this.isLock&&(this.emitter.emit("beforeUnlock",this),this.isLock=!1,this.emitter.emit("afterUnlock",this))}}class e{constructor(s){this.steps=s.steps,this.emitter=new t(s.on),s.el&&(this.el=s.el,this.lineEl=this.el.querySelector(".progress-line")),this.emitter.emit("init",this)}get width(){return this.steps.current/this.steps.last*100}update(){this.lineEl&&(console.log("progress"),this.lineEl.style.width=this.width+"%")}}class r{constructor(s){this.steps=s.steps,this.emitter=new t(s.on),this.isVisible=!1,this.isFinal=!!s.hasOwnProperty("isFinal")&&s.isFinal,s.el&&(this.el=s.el),this.emitter.emit("init",this)}get visible(){return this.isVisible}set visible(t){this.el&&this.el.classList[t?"add":"remove"]("visible"),this.isVisible=t}hide(){this.emitter.emit("beforeHide",this),this.visible=!1,this.emitter.emit("afterHide",this)}show(){this.emitter.emit("beforeShow",this),this.visible=!0,this.emitter.emit("afterShow",this)}}export default class{constructor(h){if(this.items=[],this.controls={},this.current=0,!h)throw new Error("Config is not exists");if(this.emitter=new t(h.on),h.el&&(this.el=h.el),h.items&&h.items instanceof Object)for(const t of h.items){const s=new r({steps:this,...t});this.items.push(s)}if(this.current=0,h.controls)if(Array.isArray(h.controls));else if(h.controls instanceof Object){for(const t in h.controls)if(s.hasOwnProperty(t)){const s=new i({steps:this,key:t,...h.controls[t]});s.emitter.subscribe("click",this[t].bind(this)),this.controls[t]=s}this.fixVisibility()}h.progress&&(this.progress=new e({steps:this,...h.progress}),this.progress.update()),this.emitter.emit("init",this)}get last(){return this.items.length-1}prev(){this.current<1||(this.items[this.current].hide(),this.current--,this.fixVisibility(),this.progress&&this.progress.update(),this.items[this.current].show(),console.log("Steps::prev(), current index = "+this.current))}next(){this.current>=this.last?console.log("Steps::next() ======>"):(this.items[this.current].hide(),this.current++,this.fixVisibility(),this.progress&&this.progress.update(),this.items[this.current].show(),console.log("Steps::next(), current index = "+this.current))}fixVisibility(){if(this.controls)for(const t in this.controls){const s=this.controls[t];s.validators.visibleIf(this)?!s.isVisible&&s.show():s.isVisible&&s.hide()}}destroy(){}}
//# sourceMappingURL=steps.es.min.js.map
